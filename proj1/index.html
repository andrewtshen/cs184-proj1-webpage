<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Project 1: Rasterizer</h1>
<h2 align="middle">Andrew Shen and Ryan Chan, CS184-DN</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>During this project we implement methods to efficiently and cleanly render an image in a process called rasterization. Using Barycentric coordinates, we were able to implement texture mapping so that we could apply textures to rasterized triangles. In addition, we also implemented transformations that allowed us to translate, scale, and rotate the image. We found it very interesting to go through the entire pipeline of processing and displaying an image. The rasterization process taught us a lot about the importance of paying close attention to small details in the algorithms. Though they might appear simple and easy to comprehend, small error such as off by one errors can have a drastic impact on the outcome of the renders. For example in some cases, failing to clip values to the right bounds resulted in outlines of triangles appearing and other unexpected artifacts. In all, this project gave us valuable insight to the basics of rasterization -- allowing us to take a peek under the hood of a complex process.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>In order to rasterize triangles, we first find the bounds by computing the min and max of the x and y coordinates for each vertex of the triangle. This enables us to narrow down our search significantly for potential points within this triangle. Then, we iterated through each possible point within that bounding box and performed the point-in-triangle test (as shown in the picture below) to determine if the point was in the triangle. If it was determined to be in the triangle, then that pixel would then be colored with its respective color. As a slight naunce, depending on the order of the point, the inside check may potentially fail and actually give the region outside the triangle. To correct for this, we can add an additional conditional that flips the inequality to make the triangle representation order agnositc. Finally, this algorithm is no worse than one that checks each sample in the bounding box as our algorithm goes through each pixel in the bounding box exactly once.</p>

<div align="middle">
  <table style="width=100%">
  	<tr>
  		<td>
	        <img src="images/part1_formula.png" align="middle" width="400px"/>
	        <figcaption align="middle">"Inside Triangle" Formula</figcaption>
      	</td>
  	</tr>
    <tr>
      <td>
        <img src="images/part1.png" align="middle" width="400px"/>
        <figcaption align="middle">Colorful Triangles (basic/test4.svg)</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>


<h3 align="middle">Part 2: Antialiasing triangles</h3>



<h3 align="middle">Part 3: Transforms</h3>

<p>We were trying to make cubeman do a ballerina twirl.</p>

<div align="middle">
  <table style="width=100%">
  	<tr>
  		<td>
	        <img src="images/part3.png" align="middle" width="400px"/>
	        <figcaption align="middle">Ballerina Cubeman</figcaption>
      	</td>
  	</tr>
  </table>
</div>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>

<p>Barycentric coordinates are coordinates that are used to specify the location of a point relative
  to some kind of shape, like a triangle. Because a triangle has three sides, the position of a 
  point inside the triangle can be described using three corresponding barycentric coordinates, whose values 
  sum to one and are dependent on the point's distance from each side. In the image below, 
  each side of a triangle has a different respective color. Furthermore, the color of a point within 
  the triangle can be calculated using barycentric coordinates, which essentially determine a color
  using proportions of the point's distance from each side.
</p>

<div align="middle">
  <table style="width=100%">
  	<tr>
  		<td>
	        <img src="images/part4.png" align="middle" width="400px"/>
	        <figcaption align="middle">Barycentric Coordinates for a Triangle</figcaption>
      	</td>
      <td>
          <img src="images/part4_color_gradient.png" align="middle" width="400px"/>
          <figcaption align="middle">Color Gradient Wheel</figcaption>
        </td>
  	</tr>
    <br>
  </table>
</div>

<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>

<p> Pixel sampling is mapping the values or colors from some texture onto the screen.
  In order to implement texture mapping, we calculated the barycentric coordinates of each sample within the triangle
  in screen space. Then, we calculated the position of the corresponding point in texture space using
  the same barycentric coordinates and the vertices of the texture space triangle. Once we had the corresponding point in texture space, we used either nearest or bilinear pixel sampling to map the color onto the screen. Nearest pixel sampling
  works by rounding the coordinates (x, y) to the nearest pixel. On the other hand, bilinear pixel sampling
  finds and utilizes the nearest four pixels relative to (x, y). It computes a weighted sum on those four pixels by 
  performing two instances of linear interpolation.
</p>

<div align="middle">
  <table style="width=100%">
  	<tr>
  		<td>
	        <img src="images/part5_nearest_sr1.png" align="middle" width="400px"/>
	        <figcaption align="middle">Nearest Sampling, 1 Sample Per Pixel </figcaption>
      	</td>
      <td>
	        <img src="images/part5_bilinear_sr1.png" align="middle" width="400px"/>
	        <figcaption align="middle">Bilinear Sampling, 1 Sample Per Pixel </figcaption>
      	</td>
  	</tr>
    <tr>
      <td>
        <img src="images/part5_nearest_sr16.png" align="middle" width="400px"/>
        <figcaption align="middle">Nearest Sampling, 16 Samples Per Pixel </figcaption>
      </td>
    <td>
        <img src="images/part5_bilinear_sr16.png" align="middle" width="400px"/>
        <figcaption align="middle">Bilinear Sampling, 16 Samples Per Pixel </figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/image1.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image2.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/image3.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
      <td>
        <img src="images/image4.png" align="middle" width="400px"/>
        <figcaption align="middle">Caption goes here.</figcaption>
      </td>
    </tr>
  </table>
</div>


<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
