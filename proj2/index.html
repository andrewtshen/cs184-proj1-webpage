<html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Andrew Shen and Ryan Chan</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


<!-- <b>
  Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
</b> -->
<p>
  The de Casteljau's algorithm is a method to generate Bezier curves from a set of control points by using linear interpolation recursively. We implemented the linear interpolation step to reduce n control points down to n-1 control points, which is one level of the subdivision. If we start with N control points then we can reduce to a single control point on the Bezier curve by performing N-1 subdivisions. 
</p>
<br>


<!-- <b>
  Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
</b> -->
<!-- Example of including a single figure -->
<div align="middle">
  <img src="images/proj2_part1.png" align="middle" width="50%">
  <figcaption>Our Bezier Curve</figcaption>
</div>
<br>

<!-- <b>
  Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
</b> -->
<!-- Example of including multiple figures -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/proj2_part1_level0.png" align="middle" width="400px"/>
        <figcaption>Level 0</figcaption>
      </td>
      <td>
        <img src="images/proj2_part1_level1.png" align="middle" width="400px"/>
        <figcaption>Level 1</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/proj2_part1_level2.png" align="middle" width="400px"/>
        <figcaption>Level 2</figcaption>
      </td>
      <td>
        <img src="images/proj2_part1_level3.png" align="middle" width="400px"/>
        <figcaption>Level 3</figcaption>
      </td>
    </tr>
    <br>
    <tr align="center">
      <td>
        <img src="images/proj2_part1_level4.png" align="middle" width="400px"/>
        <figcaption>Level 4</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<!-- <b>
  Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
</b> -->
<!-- Example of including multiple figures -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/proj2_part1_modified1.png" align="middle" width="400px"/>
        <figcaption>New Bezier Curve</figcaption>
      </td>
      <td>
        <img src="images/proj2_part1_modified2.png" align="middle" width="400px"/>
        <figcaption>New Bezier Curve evaluted at different value of t</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>
<br>


<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<!-- <b>
  Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.
</b> -->
<p>
    The de Casteljau algorithm extends to Bezier surfaces as it allows us to compute Bezier curves along the two different axes of a 2D set of control points. After computing Bezier curves along two axes we can identify the Bezier surfaces. To find a singular point on the Bezier surface given by coordinates (u, v), we first apply the de Casteljau algorithm to each row of the control points using u to get a vector of points. Then, we apply the de Casteljau algorithm once more using v to get a single point that is on the Bezier surface. By performing this algorithm on different values of (u, v), we can compute the Bezier surface.
</p>
<br>


<!-- <b>
  Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
</b> -->
<div align="middle">
  <img src="images/proj2_part2_teapot.png" align="middle" width="50%">
  <figcaption>Teapot</figcaption>
</div>
<br>
<br>


<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

<!-- <b>
  Briefly explain how you implemented the area-weighted vertex normals.
</b> -->
<p>
    We implemented area-weighted vertex normals by iterating through the faces in contact
    with the vertex. We started with the vertex's half-edge, then progressed onto its twin's next 
    half-edge, and so on until we reach the same half-edge that we started with. Each half-edge corresponds to a 
    different face, so for each face, we take its normal and add it to a running sum vector. After we iterate 
    through every face at the vertex, we return the average of the running sum vector, which we calculate by dividing the vector by
    the number of faces.
</p>
<br>


<!-- <b>
  Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
</b> -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/proj2_part3_teapot_without_vertex_normals.png" align="middle" width="400px"/>
        <figcaption>Teapot without vertex normals</figcaption>
      </td>
      <td>
        <img src="images/proj2_part3_teapot_with_vertex_normals.png" align="middle" width="400px"/>
        <figcaption>Teapot with vertex normals</figcaption>
      </td>
    </tr>
  </table>
</div>
<!-- <p>
    YOUR RESPONSE GOES HERE
</p> -->
<br>


<h3 align="middle">Part 4: Edge Flip</h3>
<!-- <b>
  Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
</b> -->
<p>
    We set variables for each mesh element involved in the edge flip. More specifically, there are 10 half-edges, 5 edges, 
    4 vertices, and 2 faces. We set variables because we want to maintain access to the original elements after we modify 
    other ones. We visualized the flip as rotating the "inner" figure clockwise, and adjusted the pointers accordingly. We
    started by setting the neighbors for each inner half-edge. The outer ones are not affected by the flip. Then, we set the
    half-edges for each edge, vertex, and face.
</p>
<br>


<!-- <b>
  Show screenshots of the teapot before and after some edge flips.
</b> -->
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/proj2_part4_teapot_without_flips.png" align="middle" width="400px"/>
        <figcaption>Teapot without edge flips</figcaption>
      </td>
      <td>
        <img src="images/proj2_part4_teapot_with_flips.png" align="middle" width="400px"/>
        <figcaption>Teapot with edge flips</figcaption>
      </td>
    </tr>
  </table>
</div>
<!-- <p>
    YOUR RESPONSE GOES HERE
</p> -->
<br>


<!-- <b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br> -->


<h3 align="middle">Part 5: Edge Split</h3>
<b>
  Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    We set variables for each mesh element involved in the edge flip similarly to the last question. More specifically, there are 16 half-edges, 7 edges, 5 vertices, and 4 faces in total. We used temporary variables similarly to Task 4 in order to hold intermediate values and also created 6 new half-edges, 3 new edges, 1 new vertex, and 2 new faces. In order to change as little as possible, we try to leave as many mesh objects in the same location only really changing around the assignments for the "inner" portion of the split. To implement everything, we first listed out all of the half-edges, edges, vertices, and faces so that we would not accidentally forget to update anything and tried to be as systematic as possible. Below is the diagram that we drew out in order to map out the mesh elements to the correct place.
</p>
<br>

<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/proj2_part5_split_diagram.png" align="middle" width="400px"/>
        <figcaption>Split Diagram</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<b>
    Show screenshots of a mesh before and after some edge splits. 
</b>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/proj2_part5_original_beetle.png" align="middle" width="400px"/>
        <figcaption>Beetle car without edge splits</figcaption>
      </td>
      <td>
        <img src="images/proj2_part5_split_beetle.png" align="middle" width="400px"/>
        <figcaption>Beetle car with edge splits</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
    Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
</b>
<div align="middle">
  <table style="width:100%">
    <tr align="center">
      <td>
        <img src="images/proj2_part5_original_weird.png" align="middle" width="400px"/>
        <figcaption>Weird without edge splits nor edge flips</figcaption>
      </td>
      <td>
        <img src="images/proj2_part5_split_flip_weird.png" align="middle" width="400px"/>
        <figcaption>Weird with edge splits and edge flips</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    Thankfully we didn't experience too much of an eventful debugging journey. The only problems we encountered were one or two mistakes in the assignment of variables which we fixed by carefully double checking all of the values and making sure everything was consistent with the implementation and the diagram.
</p>
<br>


<b>
    If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
</b>
<p>
    We did not get to this.
</p>
<br>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
<b>
  Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h3 align="middle">Part 7 (Optional, Possible Extra Credit)</h3>
<b>
    Save your best polygon mesh as partsevenmodel.dae in your docs folder and show us a screenshot of the mesh in your write-up.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Include a series of screenshots showing your original mesh and your mesh after one and two rounds of subdivision. If you have used custom shaders, include screenshots of your mesh with those shaders applied as well.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Describe what you have done to enhance your mesh beyond the simple humanoid mesh described in the tutorial.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


</body>
